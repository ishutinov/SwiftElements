//: [Назад](@previous)
import Foundation
//: Отсюда и далее мы начнём активно использовать всю мощь ООП (объектно-ориентированного программирования).  
//: В любом приложении всё состоит из объектов.
//: Само приложение - ни что иное как объект, состоящий из иных объектов.

//: **"Что же такое Объект?"** - спросите вы.  
//: Объект - это экземпляр Класса или Структуры. О классах мы повогорим на следующем уроке, а вот о Структурах ниже:  
//: ## Structure
//: Структура - это абстрактный тип данных, который может хранить в себе иные данные. В том числе и другие структуры.  
//: Если в двух словах, то: вы можете вынести определённый набор данных и поведения в отдельный объект
//: и использовать его в любом месте приложения. Структура по сути своей - это некий чертёж,
//: по которому в дальнейшем вы можете создавать однотипные объекты с заранее заданными различиями.
enum skillType {
  case passive, active, offensive
}

/// Наш тестовый монстр
struct Monster {
  let name: String = "Lava Golem"
  var monsterHP: Int = 24324
}

/// Наш герой
struct Player {
  // Свойство структуры. По сути, это та же переменная (или константа в нашем случае),
  // ограниченная лишь областью видимости.
  let skills: (String, skillType) = ("Iron Hand", .passive)
  let heroAtk: Int
  
  // В данном случае мы имеем действие, что наносит определённый урон.
  // Так же стоит заметить, что мы передаём внутрь функции другую структуру по ссылке (inout)
  // Тем самым меняем сам передаваемый объект.
  /// Нанесение урона.
  /// - Parameter monster: Сам объект монстра
  /// - Parameter damage: Урон который наносит герой вышеуказанному монстру
  func takingDamage(monster: inout Monster, damage: Int) {
    monster.monsterHP -= damage
  }
}

var golem: Monster = Monster()
var player: Player = Player(heroAtk: 12478)

player.takingDamage(monster: &golem, damage: player.heroAtk)

// Как видите, количество жизней у монстра уменьшилось.
golem.monsterHP
//: ## Вычисляемые свойства
struct Thief {
  var agi: Int
  var dex: Int
  let weapon: String = "Ice Pick"
  let weaponDelay: Float = 50
  var aspd: Float {
    get {
      let agiDelay: Float = (weaponDelay * Float(agi)) / 25
      let dexDelay: Float = (weaponDelay * Float(dex)) / 100
      return 200 - (weaponDelay - ((agiDelay + dexDelay) / 10))
    }
  }
}

var thief = Thief(agi: 34, dex: 15)
thief.aspd

print("\n===========")
//: ## Наблюдатели свойств
//: Наблюдатели свойств - это блоки кода, которые вызываются, когда свойства меняют свои значения.
struct Knight {
  var berserkStatus: Bool {
    // Вызывается ДО того как значение будет изменено.
    willSet {
      if berserkStatus {
        print("Рыцарь разбушевался! Врассыпную, пацаны!")
      } else {
        print("Фух! Рыцаря отпустило...")
      }
    }
  }
  
  var awakeningStatus: Bool {
    // Вызывается уже ПОСЛЕ того, как значение будет изменено.
    didSet {
      if awakeningStatus {
        print("Рыцарь проснулся.")
      } else {
        print("Спит ещё.")
      }
    }
  }
  
}

var knight = Knight(berserkStatus: false, awakeningStatus: false)
//: Поскольку используется willSet - мы видим сообщение от установленного при инициализации значения - false  
//: Несмотря на то, что по факту сразу после этого наш рыцарь пришёл таки в ярость.
knight.berserkStatus = true
//: В случае же с didSet - мы видим сообщение после обновлённого значения - true.
knight.awakeningStatus = true

print("\n===========")
//: ## Методы
//: Методы - это те же функции, только "закреплённые" за Структурами.  
//: Нам уже доводилось использовать методы ранее в этом уроке. Теперь же рассмотрим их подробнее.
struct Smith {
  var aspd: Float
  
  // Ключевое слово mutating обозначет, что функция меняет свойство самой структуры.
  /// Умение на увеличение скорости атаки.
  mutating func adrenalineRush() {
    aspd += 7
  }
  
  func repairWeapon() -> String {
    return "Оружие и снаряжение снова в порядке!"
  }
}

var smith = Smith(aspd: 163)
smith.adrenalineRush()
smith.aspd
smith.repairWeapon()

print("\n===========\n")
//: ## Конструкторы
//: Конструкторы - это специализированные методы, позволяющие создавать экземпляр структуры.
struct BananaHat {
  var name: String
  var reuiredLevel: Int?
  let weight: Int
  var defense: Int
  
  // Мы сами выбираем какие из параметров задать заранее,
  // а какие предоставить на изменение создателю объекта Структуры.
  // Названия для входящих параметров могут быть любыми.
  // Но желаельно делать их похожими на оригинальные названия, дабы избежать путаницы.
  init(def: Int) {
    name = "Banana Hat"
    reuiredLevel = nil
    weight = 20
    
    // В данном случае мы задали несколько свойств заранее,
    // а одно оставили доступным для изменения.
    self.defense = def
  }
}
//: Поскольку мы уже задали значения свойств заранее, через инициализатор,
//: мы уже не сможем задать их при создании объекта Структуры (за исключением defense).
let bananaHat = BananaHat(def: 1)
//: ## Опциональный конструктор
struct Stunner {
  var slots: Int

  // Делаем проверку на отрицательные величины.
  // Если вдруг нам в инициализатор попадёт отрицательное число, то программа не упадёт с ошибкой,
  // а вернёт пустое значение.
  init?(slotsNumber: Int) {
    self.slots = slotsNumber
    guard slots > 0 else {
      return nil
    }
  }
}


let stunner = Stunner(slotsNumber: -2)
//: Стоит заметить, что количество инициализаторов не ограничено. Вы можете заранее задать несколько на выбор.
print("\n===========\n")
//: ## Домашнее задание
//: Воспользуйтесь получеными знаниями на практике.

//: [Вперёд](@next)
